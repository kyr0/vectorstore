{"version":3,"file":"hnswlib.js","sources":["../lib/constants.ts","../lib/index.ts"],"sourcesContent":["/***************** GENERATED FILE ********************/ \nexport const defaultParams = {\n  /**\n   * Default parameters for the HNSW index.\n   * @param {number} m The maximum number of outgoing connections on the graph (default: 16).\n   * @param {number} efConstruction The parameter that controls speed/accuracy trade-off during the index construction (default: 200).\n   * @param {number} randomSeed The seed value of random number generator (default: 100).\n   */\n  initIndex: [32, 128, 100],\n} as const;\n\nexport type defaultParamtersTypes = keyof typeof defaultParams;\n\nexport const hnswParamsForAda = {\n  m: 32,\n  efSearch: 128,\n  efConstruction: 128,\n  numNeighbors: 8,\n  dimensions: 1538,\n} as const;\n \n/***************** GENERATED FILE ********************/ \n","/***************** GENERATED FILE ********************/ \nimport type * as module from './hnswlib-wasm';\nimport type factory from './hnswlib-wasm';\n// import './hnswlib.mjs';\n\nexport type HierarchicalNSW = module.HierarchicalNSW;\nexport type BruteforceSearch = module.BruteforceSearch;\nexport type EmscriptenFileSystemManager = module.EmscriptenFileSystemManager;\nexport type L2Space = module.L2Space;\nexport type InnerProductSpace = module.InnerProductSpace;\n\nexport type HnswModuleFactory = typeof factory;\nexport type normalizePoint = HnswlibModule['normalizePoint'];\nexport const IDBFS_STORE_NAME = 'FILE_DATA';\n\nexport * from './constants';\n\nexport interface HnswlibModule extends Omit<EmscriptenModule, '_malloc' | '_free'> {\n  normalizePoint(vec: number[]): number[];\n  L2Space: typeof module.L2Space;\n  InnerProductSpace: typeof module.InnerProductSpace;\n  BruteforceSearch: typeof module.BruteforceSearch;\n  HierarchicalNSW: typeof module.HierarchicalNSW;\n  EmscriptenFileSystemManager: typeof module.EmscriptenFileSystemManager;\n  asm: {\n    malloc(size: number): number;\n    free(ptr: number): void;\n  };\n}\n\nlet library: Awaited<HnswlibModule>;\ntype InputFsType = 'IDBFS' | undefined;\n\nexport const syncFileSystem = (action: 'read' | 'write'): Promise<void> => {\n  const EmscriptenFileSystemManager: HnswlibModule['EmscriptenFileSystemManager'] = library.EmscriptenFileSystemManager;\n\n  const syncAction = action === 'read' ? true : action === 'write' ? false : undefined;\n  if (syncAction === undefined) throw new Error('Invalid action type');\n\n  return new Promise((resolve, reject) => {\n    try {\n      EmscriptenFileSystemManager.syncFS(syncAction, () => {\n        resolve();\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n};\n\nexport const waitForFileSystemInitalized = (): Promise<void> => {\n  const EmscriptenFileSystemManager: HnswlibModule['EmscriptenFileSystemManager'] = library.EmscriptenFileSystemManager;\n  return new Promise((resolve, reject) => {\n    let totalWaitTime = 0;\n    const checkInterval = 100; // Check every 100ms\n    const maxWaitTime = 4000; // Maximum wait time of 4 seconds\n\n    const checkInitialization = () => {\n      if (EmscriptenFileSystemManager.isInitialized()) {\n        resolve();\n      } else if (totalWaitTime >= maxWaitTime) {\n        reject(new Error('Failed to initialize filesystem'));\n      } else {\n        totalWaitTime += checkInterval;\n        setTimeout(checkInitialization, checkInterval);\n      }\n    };\n\n    setTimeout(checkInitialization, checkInterval);\n  });\n};\n\nexport const waitForFileSystemSynced = (): Promise<void> => {\n  const EmscriptenFileSystemManager = library.EmscriptenFileSystemManager;\n  return new Promise((resolve, reject) => {\n    let totalWaitTime = 0;\n    const checkInterval = 100; // Check every 100ms\n    const maxWaitTime = 4000; // Maximum wait time of 4 seconds\n\n    const checkInitialization = () => {\n      if (EmscriptenFileSystemManager.isSynced()) {\n        resolve();\n      } else if (totalWaitTime >= maxWaitTime) {\n        reject(new Error('Failed to initialize filesystem'));\n      } else {\n        totalWaitTime += checkInterval;\n        setTimeout(checkInitialization, checkInterval);\n      }\n    };\n\n    setTimeout(checkInitialization, checkInterval);\n  });\n};\n\n/**\n * Initializes the file system for the HNSW library using the specified file system type.\n * If no file system type is specified, IDBFS is used by default.\n * @param inputFsType The type of file system to use. Can be 'IDBFS' or undefined.\n * @returns A promise that resolves when the file system is initialized, or rejects if initialization fails.\n */\nconst initializeFileSystemAsync = async (inputFsType?: InputFsType): Promise<void> => {\n  const fsType = inputFsType == null ? 'IDBFS' : inputFsType;\n  const EmscriptenFileSystemManager = library.EmscriptenFileSystemManager;\n\n  if (EmscriptenFileSystemManager.isInitialized()) {\n    return;\n  }\n  EmscriptenFileSystemManager.initializeFileSystem(fsType);\n  return await waitForFileSystemInitalized();\n};\n\n/**\n * Load the HNSW library in node or browser\n */\nexport const loadHnswlib = async (inputFsType?: InputFsType): Promise<HnswlibModule> => {\n  try {\n    // @ts-expect-error - hnswlib can be a global variable in the browser\n    if (typeof hnswlib !== 'undefined' && hnswlib !== null) {\n      // @ts-expect-error - hnswlib can be a global variable in the browser\n      const lib = hnswlib();\n      if (lib != null) return lib;\n    }\n\n    if (!library) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      const temp = await import('./hnswlib.mjs');\n      const factoryFunc = temp.default;\n\n      library = await factoryFunc();\n      await initializeFileSystemAsync(inputFsType);\n      return library; // Add this line\n    }\n    return library;\n  } catch (err) {\n    console.error('----------------------------------------');\n    console.error('Error initializing the library:', err);\n    throw err;\n  }\n};\n\n// disabled due to lack of perfomance improvemant and additional complexity\n\n// /**\n//  * Adds items and their corresponding labels to the HierarchicalNSW index using memory pointers.\n//  * This function handles the memory allocation for the Emscripten Module, and properly frees the memory after use.  its a wrapper around {@link HierarchicalNSW#addItemsWithPtrs}\n//  *\n//  * ⛔️ This function is only 1.02x faster than vectors for 10k points version which are easier to use.  The sole advantage is memory savings\n//  *\n//  * @async\n//  * @param {HnswlibModule} Module - The Emscripten HNSWLIB Module object.\n//  * @param {HierarchicalNSW} index - The HierarchicalNSW index object.\n//  * @param {Float32Array[] | number[][]} items - An array of item vectors to be added to the search index. Each item should be a Float32Array or an array of numbers.\n//  * @param {number[]} labels - An array of numeric labels corresponding to the items. The length of the labels array should match the length of the items array.\n//  * @param {boolean} replaceDeleted - A flag to determine if deleted elements should be replaced (default: false).\n//  * @returns {Promise<void>} A promise that resolves once the items and labels have been added to the index.\n//  */\n// export const addItemsWithPtrsHelper = async (\n//   Module: HnswlibModule,\n//   index: HierarchicalNSW,\n//   items: Float32Array[] | number[][],\n//   labels: number[],\n//   replaceDeleted: boolean\n// ): Promise<void> => {\n//   const itemCount = items.length;\n//   const dim = items[0].length;\n\n//   // Flatten the items array into a Float32Array\n//   const flatItems = new Float32Array(itemCount * dim);\n//   items.forEach((vec, i) => {\n//     flatItems.set(vec, i * dim);\n//   });\n\n//   // Convert labels to a Uint32Array\n//   const labelsArray = new Uint32Array(labels);\n\n//   const vecDataPtr = Module.asm.malloc(flatItems.length * Float32Array.BYTES_PER_ELEMENT);\n//   const labelVecDataPtr = Module.asm.malloc(labelsArray.length * Uint32Array.BYTES_PER_ELEMENT);\n\n//   if (vecDataPtr === 0) {\n//     throw new Error('Failed to allocate memory for vecDataPtr.');\n//   }\n\n//   if (labelVecDataPtr === 0) {\n//     throw new Error('Failed to allocate memory for labelVecDataPtr.');\n//   }\n\n//   Module.HEAPF32.set(flatItems, vecDataPtr / Float32Array.BYTES_PER_ELEMENT);\n//   Module.HEAPU32.set(labelsArray, labelVecDataPtr / Uint32Array.BYTES_PER_ELEMENT);\n\n//   await index.addItemsWithPtr(\n//     Module.HEAPF32.subarray(\n//       Math.floor(vecDataPtr / Float32Array.BYTES_PER_ELEMENT),\n//       Math.floor(vecDataPtr / Float32Array.BYTES_PER_ELEMENT) + itemCount * dim\n//     ),\n//     itemCount * dim,\n//     Module.HEAPU32.subarray(\n//       Math.floor(labelVecDataPtr / Uint32Array.BYTES_PER_ELEMENT),\n//       Math.floor(labelVecDataPtr / Uint32Array.BYTES_PER_ELEMENT) + itemCount\n//     ),\n//     itemCount,\n//     replaceDeleted\n//   );\n\n//   Module.asm.free(vecDataPtr);\n//   Module.asm.free(labelVecDataPtr);\n// };\n \n/***************** GENERATED FILE ********************/ \n"],"names":[],"mappings":"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"}